import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, inject, Input, NgZone, ViewChildren, ViewEncapsulation, } from '@angular/core';
import { distinctUntilChanged, skip, startWith } from 'rxjs/operators';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { ngbNavFadeInTransition, ngbNavFadeOutTransition } from './nav-transition';
import { ngbRunTransition } from '../util/transition/ngbTransition';
import { NgFor, NgIf, NgTemplateOutlet } from '@angular/common';
import * as i0 from "@angular/core";
export class NgbNavPane {
    constructor() {
        this.nativeElement = inject(ElementRef).nativeElement;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbNavPane, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.0.0", type: NgbNavPane, isStandalone: true, selector: "[ngbNavPane]", inputs: { item: "item", nav: "nav", role: "role" }, host: { properties: { "id": "item.panelDomId", "class.fade": "nav.animation", "attr.role": "role ? role : nav.roles ? \"tabpanel\" : undefined", "attr.aria-labelledby": "item.domId" }, classAttribute: "tab-pane" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbNavPane, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngbNavPane]',
                    standalone: true,
                    host: {
                        '[id]': 'item.panelDomId',
                        class: 'tab-pane',
                        '[class.fade]': 'nav.animation',
                        '[attr.role]': 'role ? role : nav.roles ? "tabpanel" : undefined',
                        '[attr.aria-labelledby]': 'item.domId',
                    },
                }]
        }], propDecorators: { item: [{
                type: Input
            }], nav: [{
                type: Input
            }], role: [{
                type: Input
            }] } });
/**
 * The outlet where currently active nav content will be displayed.
 *
 * @since 5.2.0
 */
export class NgbNavOutlet {
    constructor() {
        this._cd = inject(ChangeDetectorRef);
        this._ngZone = inject(NgZone);
        this._activePane = null;
    }
    isPanelTransitioning(item) {
        return this._activePane?.item === item;
    }
    ngAfterViewInit() {
        // initial display
        this._updateActivePane();
        // this will be emitted for all 3 types of nav changes: .select(), [activeId] or (click)
        this.nav.navItemChange$
            .pipe(takeUntilDestroyed(this.nav.destroyRef), startWith(this._activePane?.item || null), distinctUntilChanged(), skip(1))
            .subscribe((nextItem) => {
            const options = { animation: this.nav.animation, runningTransition: 'stop' };
            // next panel we're switching to will only appear in DOM after the change detection is done
            // and `this._panes` will be updated
            this._cd.detectChanges();
            // fading out
            if (this._activePane) {
                ngbRunTransition(this._ngZone, this._activePane.nativeElement, ngbNavFadeOutTransition, options).subscribe(() => {
                    const activeItem = this._activePane?.item;
                    this._activePane = this._getPaneForItem(nextItem);
                    // mark for check when transition finishes as outlet or parent containers might be OnPush
                    // without this the panes that have "faded out" will stay in DOM
                    this._cd.markForCheck();
                    // fading in
                    if (this._activePane) {
                        // we have to add the '.active' class before running the transition,
                        // because it should be in place before `ngbRunTransition` does `reflow()`
                        this._activePane.nativeElement.classList.add('active');
                        ngbRunTransition(this._ngZone, this._activePane.nativeElement, ngbNavFadeInTransition, options).subscribe(() => {
                            if (nextItem) {
                                nextItem.shown.emit();
                                this.nav.shown.emit(nextItem.id);
                            }
                        });
                    }
                    if (activeItem) {
                        activeItem.hidden.emit();
                        this.nav.hidden.emit(activeItem.id);
                    }
                });
            }
            else {
                this._updateActivePane();
            }
        });
    }
    _updateActivePane() {
        this._activePane = this._getActivePane();
        this._activePane?.nativeElement.classList.add('show');
        this._activePane?.nativeElement.classList.add('active');
    }
    _getPaneForItem(item) {
        return (this._panes && this._panes.find((pane) => pane.item === item)) || null;
    }
    _getActivePane() {
        return (this._panes && this._panes.find((pane) => pane.item.active)) || null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbNavOutlet, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.0", type: NgbNavOutlet, isStandalone: true, selector: "[ngbNavOutlet]", inputs: { paneRole: "paneRole", nav: ["ngbNavOutlet", "nav"] }, host: { properties: { "class.tab-content": "true" } }, viewQueries: [{ propertyName: "_panes", predicate: NgbNavPane, descendants: true }], ngImport: i0, template: `
		<ng-template ngFor let-item [ngForOf]="nav.items">
			<div
				ngbNavPane
				*ngIf="item.isPanelInDom() || isPanelTransitioning(item)"
				[item]="item"
				[nav]="nav"
				[role]="paneRole"
			>
				<ng-template
					[ngTemplateOutlet]="item.contentTpl?.templateRef || null"
					[ngTemplateOutletContext]="{ $implicit: item.active || isPanelTransitioning(item) }"
				></ng-template>
			</div>
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "directive", type: NgbNavPane, selector: "[ngbNavPane]", inputs: ["item", "nav", "role"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbNavOutlet, decorators: [{
            type: Component,
            args: [{
                    selector: '[ngbNavOutlet]',
                    standalone: true,
                    imports: [NgbNavPane, NgFor, NgIf, NgTemplateOutlet],
                    host: { '[class.tab-content]': 'true' },
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
		<ng-template ngFor let-item [ngForOf]="nav.items">
			<div
				ngbNavPane
				*ngIf="item.isPanelInDom() || isPanelTransitioning(item)"
				[item]="item"
				[nav]="nav"
				[role]="paneRole"
			>
				<ng-template
					[ngTemplateOutlet]="item.contentTpl?.templateRef || null"
					[ngTemplateOutletContext]="{ $implicit: item.active || isPanelTransitioning(item) }"
				></ng-template>
			</div>
		</ng-template>
	`,
                }]
        }], propDecorators: { _panes: [{
                type: ViewChildren,
                args: [NgbNavPane]
            }], paneRole: [{
                type: Input
            }], nav: [{
                type: Input,
                args: ['ngbNavOutlet']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LW91dGxldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9uYXYvbmF2LW91dGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRU4sdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUNMLE1BQU0sRUFFTixZQUFZLEVBQ1osaUJBQWlCLEdBQ2pCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdkUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFFaEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLHVCQUF1QixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbkYsT0FBTyxFQUFFLGdCQUFnQixFQUF3QixNQUFNLGtDQUFrQyxDQUFDO0FBRTFGLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7O0FBYWhFLE1BQU0sT0FBTyxVQUFVO0lBWHZCO1FBWUMsa0JBQWEsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBNEIsQ0FBQztLQUtoRTs4R0FOWSxVQUFVO2tHQUFWLFVBQVU7OzJGQUFWLFVBQVU7a0JBWHRCLFNBQVM7bUJBQUM7b0JBQ1YsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLFVBQVUsRUFBRSxJQUFJO29CQUNoQixJQUFJLEVBQUU7d0JBQ0wsTUFBTSxFQUFFLGlCQUFpQjt3QkFDekIsS0FBSyxFQUFFLFVBQVU7d0JBQ2pCLGNBQWMsRUFBRSxlQUFlO3dCQUMvQixhQUFhLEVBQUUsa0RBQWtEO3dCQUNqRSx3QkFBd0IsRUFBRSxZQUFZO3FCQUN0QztpQkFDRDs4QkFJUyxJQUFJO3NCQUFaLEtBQUs7Z0JBQ0csR0FBRztz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QkFDRDs4QkFPa0MsTUFBTTtzQkFBdkMsWUFBWTt1QkFBQyxVQUFVO2dCQUtmLFFBQVE7c0JBQWhCLEtBQUs7Z0JBS2lCLEdBQUc7c0JBQXpCLEtBQUs7dUJBQUMsY0FBYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEFmdGVyVmlld0luaXQsXG5cdENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuXHRDaGFuZ2VEZXRlY3RvclJlZixcblx0Q29tcG9uZW50LFxuXHREaXJlY3RpdmUsXG5cdEVsZW1lbnRSZWYsXG5cdGluamVjdCxcblx0SW5wdXQsXG5cdE5nWm9uZSxcblx0UXVlcnlMaXN0LFxuXHRWaWV3Q2hpbGRyZW4sXG5cdFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBza2lwLCBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyB0YWtlVW50aWxEZXN0cm95ZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5cbmltcG9ydCB7IG5nYk5hdkZhZGVJblRyYW5zaXRpb24sIG5nYk5hdkZhZGVPdXRUcmFuc2l0aW9uIH0gZnJvbSAnLi9uYXYtdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBuZ2JSdW5UcmFuc2l0aW9uLCBOZ2JUcmFuc2l0aW9uT3B0aW9ucyB9IGZyb20gJy4uL3V0aWwvdHJhbnNpdGlvbi9uZ2JUcmFuc2l0aW9uJztcbmltcG9ydCB7IE5nYk5hdiwgTmdiTmF2SXRlbSB9IGZyb20gJy4vbmF2JztcbmltcG9ydCB7IE5nRm9yLCBOZ0lmLCBOZ1RlbXBsYXRlT3V0bGV0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuQERpcmVjdGl2ZSh7XG5cdHNlbGVjdG9yOiAnW25nYk5hdlBhbmVdJyxcblx0c3RhbmRhbG9uZTogdHJ1ZSxcblx0aG9zdDoge1xuXHRcdCdbaWRdJzogJ2l0ZW0ucGFuZWxEb21JZCcsXG5cdFx0Y2xhc3M6ICd0YWItcGFuZScsXG5cdFx0J1tjbGFzcy5mYWRlXSc6ICduYXYuYW5pbWF0aW9uJyxcblx0XHQnW2F0dHIucm9sZV0nOiAncm9sZSA/IHJvbGUgOiBuYXYucm9sZXMgPyBcInRhYnBhbmVsXCIgOiB1bmRlZmluZWQnLFxuXHRcdCdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ2l0ZW0uZG9tSWQnLFxuXHR9LFxufSlcbmV4cG9ydCBjbGFzcyBOZ2JOYXZQYW5lIHtcblx0bmF0aXZlRWxlbWVudCA9IGluamVjdChFbGVtZW50UmVmKS5uYXRpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuXG5cdEBJbnB1dCgpIGl0ZW06IE5nYk5hdkl0ZW07XG5cdEBJbnB1dCgpIG5hdjogTmdiTmF2O1xuXHRASW5wdXQoKSByb2xlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhlIG91dGxldCB3aGVyZSBjdXJyZW50bHkgYWN0aXZlIG5hdiBjb250ZW50IHdpbGwgYmUgZGlzcGxheWVkLlxuICpcbiAqIEBzaW5jZSA1LjIuMFxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdbbmdiTmF2T3V0bGV0XScsXG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdGltcG9ydHM6IFtOZ2JOYXZQYW5lLCBOZ0ZvciwgTmdJZiwgTmdUZW1wbGF0ZU91dGxldF0sXG5cdGhvc3Q6IHsgJ1tjbGFzcy50YWItY29udGVudF0nOiAndHJ1ZScgfSxcblx0ZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIm5hdi5pdGVtc1wiPlxuXHRcdFx0PGRpdlxuXHRcdFx0XHRuZ2JOYXZQYW5lXG5cdFx0XHRcdCpuZ0lmPVwiaXRlbS5pc1BhbmVsSW5Eb20oKSB8fCBpc1BhbmVsVHJhbnNpdGlvbmluZyhpdGVtKVwiXG5cdFx0XHRcdFtpdGVtXT1cIml0ZW1cIlxuXHRcdFx0XHRbbmF2XT1cIm5hdlwiXG5cdFx0XHRcdFtyb2xlXT1cInBhbmVSb2xlXCJcblx0XHRcdD5cblx0XHRcdFx0PG5nLXRlbXBsYXRlXG5cdFx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwiaXRlbS5jb250ZW50VHBsPy50ZW1wbGF0ZVJlZiB8fCBudWxsXCJcblx0XHRcdFx0XHRbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IGl0ZW0uYWN0aXZlIHx8IGlzUGFuZWxUcmFuc2l0aW9uaW5nKGl0ZW0pIH1cIlxuXHRcdFx0XHQ+PC9uZy10ZW1wbGF0ZT5cblx0XHRcdDwvZGl2PlxuXHRcdDwvbmctdGVtcGxhdGU+XG5cdGAsXG59KVxuZXhwb3J0IGNsYXNzIE5nYk5hdk91dGxldCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXHRwcml2YXRlIF9jZCA9IGluamVjdChDaGFuZ2VEZXRlY3RvclJlZik7XG5cdHByaXZhdGUgX25nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xuXG5cdHByaXZhdGUgX2FjdGl2ZVBhbmU6IE5nYk5hdlBhbmUgfCBudWxsID0gbnVsbDtcblxuXHRAVmlld0NoaWxkcmVuKE5nYk5hdlBhbmUpIHByaXZhdGUgX3BhbmVzOiBRdWVyeUxpc3Q8TmdiTmF2UGFuZT47XG5cblx0LyoqXG5cdCAqIEEgcm9sZSB0byBzZXQgb24gdGhlIG5hdiBwYW5lXG5cdCAqL1xuXHRASW5wdXQoKSBwYW5lUm9sZTtcblxuXHQvKipcblx0ICogUmVmZXJlbmNlIHRvIHRoZSBgTmdiTmF2YFxuXHQgKi9cblx0QElucHV0KCduZ2JOYXZPdXRsZXQnKSBuYXY6IE5nYk5hdjtcblxuXHRpc1BhbmVsVHJhbnNpdGlvbmluZyhpdGVtOiBOZ2JOYXZJdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZVBhbmU/Lml0ZW0gPT09IGl0ZW07XG5cdH1cblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0Ly8gaW5pdGlhbCBkaXNwbGF5XG5cdFx0dGhpcy5fdXBkYXRlQWN0aXZlUGFuZSgpO1xuXG5cdFx0Ly8gdGhpcyB3aWxsIGJlIGVtaXR0ZWQgZm9yIGFsbCAzIHR5cGVzIG9mIG5hdiBjaGFuZ2VzOiAuc2VsZWN0KCksIFthY3RpdmVJZF0gb3IgKGNsaWNrKVxuXHRcdHRoaXMubmF2Lm5hdkl0ZW1DaGFuZ2UkXG5cdFx0XHQucGlwZShcblx0XHRcdFx0dGFrZVVudGlsRGVzdHJveWVkKHRoaXMubmF2LmRlc3Ryb3lSZWYpLFxuXHRcdFx0XHRzdGFydFdpdGgodGhpcy5fYWN0aXZlUGFuZT8uaXRlbSB8fCBudWxsKSxcblx0XHRcdFx0ZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcblx0XHRcdFx0c2tpcCgxKSxcblx0XHRcdClcblx0XHRcdC5zdWJzY3JpYmUoKG5leHRJdGVtKSA9PiB7XG5cdFx0XHRcdGNvbnN0IG9wdGlvbnM6IE5nYlRyYW5zaXRpb25PcHRpb25zPHVuZGVmaW5lZD4gPSB7IGFuaW1hdGlvbjogdGhpcy5uYXYuYW5pbWF0aW9uLCBydW5uaW5nVHJhbnNpdGlvbjogJ3N0b3AnIH07XG5cblx0XHRcdFx0Ly8gbmV4dCBwYW5lbCB3ZSdyZSBzd2l0Y2hpbmcgdG8gd2lsbCBvbmx5IGFwcGVhciBpbiBET00gYWZ0ZXIgdGhlIGNoYW5nZSBkZXRlY3Rpb24gaXMgZG9uZVxuXHRcdFx0XHQvLyBhbmQgYHRoaXMuX3BhbmVzYCB3aWxsIGJlIHVwZGF0ZWRcblx0XHRcdFx0dGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpO1xuXG5cdFx0XHRcdC8vIGZhZGluZyBvdXRcblx0XHRcdFx0aWYgKHRoaXMuX2FjdGl2ZVBhbmUpIHtcblx0XHRcdFx0XHRuZ2JSdW5UcmFuc2l0aW9uKHRoaXMuX25nWm9uZSwgdGhpcy5fYWN0aXZlUGFuZS5uYXRpdmVFbGVtZW50LCBuZ2JOYXZGYWRlT3V0VHJhbnNpdGlvbiwgb3B0aW9ucykuc3Vic2NyaWJlKFxuXHRcdFx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhY3RpdmVJdGVtID0gdGhpcy5fYWN0aXZlUGFuZT8uaXRlbTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlUGFuZSA9IHRoaXMuX2dldFBhbmVGb3JJdGVtKG5leHRJdGVtKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBtYXJrIGZvciBjaGVjayB3aGVuIHRyYW5zaXRpb24gZmluaXNoZXMgYXMgb3V0bGV0IG9yIHBhcmVudCBjb250YWluZXJzIG1pZ2h0IGJlIE9uUHVzaFxuXHRcdFx0XHRcdFx0XHQvLyB3aXRob3V0IHRoaXMgdGhlIHBhbmVzIHRoYXQgaGF2ZSBcImZhZGVkIG91dFwiIHdpbGwgc3RheSBpbiBET01cblx0XHRcdFx0XHRcdFx0dGhpcy5fY2QubWFya0ZvckNoZWNrKCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gZmFkaW5nIGluXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl9hY3RpdmVQYW5lKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSB0byBhZGQgdGhlICcuYWN0aXZlJyBjbGFzcyBiZWZvcmUgcnVubmluZyB0aGUgdHJhbnNpdGlvbixcblx0XHRcdFx0XHRcdFx0XHQvLyBiZWNhdXNlIGl0IHNob3VsZCBiZSBpbiBwbGFjZSBiZWZvcmUgYG5nYlJ1blRyYW5zaXRpb25gIGRvZXMgYHJlZmxvdygpYFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2FjdGl2ZVBhbmUubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblx0XHRcdFx0XHRcdFx0XHRuZ2JSdW5UcmFuc2l0aW9uKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fbmdab25lLFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlUGFuZS5uYXRpdmVFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmdiTmF2RmFkZUluVHJhbnNpdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMsXG5cdFx0XHRcdFx0XHRcdFx0KS5zdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5leHRJdGVtKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5leHRJdGVtLnNob3duLmVtaXQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5uYXYuc2hvd24uZW1pdChuZXh0SXRlbS5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoYWN0aXZlSXRlbSkge1xuXHRcdFx0XHRcdFx0XHRcdGFjdGl2ZUl0ZW0uaGlkZGVuLmVtaXQoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLm5hdi5oaWRkZW4uZW1pdChhY3RpdmVJdGVtLmlkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUFjdGl2ZVBhbmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIF91cGRhdGVBY3RpdmVQYW5lKCkge1xuXHRcdHRoaXMuX2FjdGl2ZVBhbmUgPSB0aGlzLl9nZXRBY3RpdmVQYW5lKCk7XG5cdFx0dGhpcy5fYWN0aXZlUGFuZT8ubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG5cdFx0dGhpcy5fYWN0aXZlUGFuZT8ubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblx0fVxuXG5cdHByaXZhdGUgX2dldFBhbmVGb3JJdGVtKGl0ZW06IE5nYk5hdkl0ZW0gfCBudWxsKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9wYW5lcyAmJiB0aGlzLl9wYW5lcy5maW5kKChwYW5lKSA9PiBwYW5lLml0ZW0gPT09IGl0ZW0pKSB8fCBudWxsO1xuXHR9XG5cblx0cHJpdmF0ZSBfZ2V0QWN0aXZlUGFuZSgpOiBOZ2JOYXZQYW5lIHwgbnVsbCB7XG5cdFx0cmV0dXJuICh0aGlzLl9wYW5lcyAmJiB0aGlzLl9wYW5lcy5maW5kKChwYW5lKSA9PiBwYW5lLml0ZW0uYWN0aXZlKSkgfHwgbnVsbDtcblx0fVxufVxuIl19